<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<title>XV: The Control Window, part 4/6</title>
<meta name="FORMATTER" content="Microsoft FrontPage 2.0">
</head>

<body background="images/blutxtr2.jpg" bgcolor="#ABABD6">
<p>
<a href="https://xv.trilon.com">
<img src="images/small_banner.gif" width="630" height="25" border="0"></a>
</p>

<h2><a name="cropping-commands">Cropping Commands</a></h2>

<dl>
    <dt><a name="crop"><img src="images/fig-064.gif" width="72"
        height="25"></a></dt>
    <dd>Crops the image to the current selection rectangle. This
        command is only available when a cropping rectangle has
        been drawn on the image. See &quot;<a
        href="image-window.html#cropping">Cropping</a>&quot; for
        further information.<br>
        Keyboard Equivalent: <b>c</b> </dd>
    <dt>&nbsp;</dt>
    <dt><a name="uncrop"><img src="images/fig-065.gif" width="72"
        height="25"></a></dt>
    <dd>Returns the image to its normal, uncropped state. This
        command is only available after the image has been
        cropped. See &quot;<a href="image-window.html#cropping">Cropping</a>&quot;
        for further information.<br>
        Keyboard Equivalent: <b>u</b> </dd>
    <dt>&nbsp;</dt>
    <dt><a name="autocrop"><img src="images/fig-066.gif"
        width="72" height="25"></a></dt>
    <dd>Crops off any constant-color borders that exist in the
        image. It will crop to the smallest rectangle that
        encloses the 'interesting' section of the image. It may
        not always appear to work because of minor invisible
        color changes in the image. As such, it works best on
        computer-generated images, and not as well on scanned
        images. In an attempt to get around this problem, if you <b>AutoCrop</b>
        while in <b>24-bit Mode</b> , it will crop off portions
        that change by a little bit, not just portions that are
        exactly the same. Not that it works all that well.<br>
        Keyboard Equivalent: <b>C</b> </dd>
</dl>

<p>Also, you can 'fine-crop' an image, by holding the <b>&lt;Ctrl&gt;</b>
key and pressing the arrow keys on your keyboard. Each press of
the keys will remove one row (or column) of pixels from the
appropriate edge. For example, pressing <b>&lt;Ctrl&gt;&lt;Up&gt;</b>
will crop off the bottom row of the image. Likewise, <b>&lt;Ctrl&gt;&lt;Down&gt;</b>
will crop off the top row, <b>&lt;Ctrl&gt;&lt;Left&gt; </b>will
crop off the right edge, and <b>&lt;Ctrl&gt;&lt;Right&gt;</b>
will crop off the left edge. It may sound backwards, but it does
the Right Thing. </p>

<p>This 'fine-cropping' will work regardless of whether or not
there is a selection rectangle currently drawn. If you
accidentally crop too much off the image, you can use the <b>UnCrop</b>
command described above to get the original image back.</p>

<p>Note that cropping never actually changes the image, only what
portions are displayed. The original image can always be restored
using the <b>UnCrop</b> command. Also, note that the 'cropping'
commands and the 'zoom' commands (See &quot;<a
href="image-window.html#zooming">Zooming</a>&quot; ) are related,
in that both affect the 'visible portion' of the image. The
cropping commands maintain the same expansion factors by making
the window larger or smaller, while the zooming commands maintain
the same window size, and stretch the relevant portion of the
image to fit. As such, the <b>UnCrop</b> command will also undo
an zooming that you may have done.</p>

<h2><a name="cut-paste-commands">Image Cut and Paste Commands</a></h2>

<p>A new feature added to Version 3.10 is the ability to cut and
paste arbitrary rectangular portions of images. You can cut (and
copy) and paste within a single image, between two different
images, or even between two running copies of <i>xv.</i> You can
even cut or copy a portion of an image, exit <i>xv</i>, go out
for dinner, come back, restart <i>xv</i> , and paste the
previously-copied portion into the current image.</p>

<p>Copied image data is normally stored within the X Server's
memory (in the '<tt>XV_CLIPBOARD</tt>' property), and remains
there until some other data is copied, or until the X Server is
reset (i.e., when you log off). This allows you to transfer image
data between different copies of <i>xv</i>, and the <i>xv</i>'s
can even be running on different machines.</p>

<p>If there is not enough server memory available to hold the
copied image data (this can happen if you copy a large amount of
data, and you're using an X Terminal, as opposed to a
workstation), <i>xv</i> will detect this, and fall back to using
a file ('<tt>.xvclip</tt>') in your home directory. Needless to
say, this precludes transferring data between <i>xv</i>'s running
on different machines, but it's better than nothing. </p>

<dl>
    <dt><a name="copy"><img src="images/fig-067.gif" width="36"
        height="25"></a></dt>
    <dd><b>Copy</b> . First, you must select a region to copy,
        via the selection rectangle mechanism (See &quot;<a
        href="image-window.html#selection-rectangle">Selection
        Rectangle</a>&quot; ). Then, use this command to copy the
        selected data to the 'clipboard'.<br>
        Keyboard Equivalent: <b>&lt;Meta&gt; c</b></dd>
    <dt>&nbsp;</dt>
    <dt><a name="cut"><img src="images/fig-068.gif" width="36"
        height="25"></a></dt>
    <dd><b>Cut</b> . Operates just like the <b>Copy</b> command,
        except that it also clears the selection to the 'current
        color', which is set using the pixel measurement tool.
        See &quot;<a
        href="image-window.html#displaying-pixel-values">Displaying
        Pixel Values</a>&quot; for further information.<br>
        Keyboard Equivalent: <b>&lt;Meta&gt; x</b></dd>
    <dt>&nbsp;</dt>
    <dt><a name="paste"><img src="images/fig-069.gif" width="36"
        height="25"></a></dt>
    <dd><b>Paste</b> . If there is no selection rectangle
        currently drawn, the first time you issue the <b>Paste</b>
        command, it will create a selection rectangle the size
        and shape of the image data that will be pasted. You may
        move and resize this rectangle as you see fit (See &quot;<a
        href="image-window.html#selection-rectangle">Selection
        Rectangle</a>&quot; ). Then, when you have the selection
        appropriately adjusted, hit <b>Paste</b> a second time to
        actually paste the clipboard contents onto the image. <p>On
        the other hand, if you have a selection rectangle drawn
        when you hit <b>Paste</b> the first time, the image will
        be pasted into the selected area immediately.<br>
        Keyboard Equivalent: <b>&lt;Meta&gt; v</b> </p>
    </dd>
    <dt><a name="clear"><img src="images/fig-070.gif" width="36"
        height="25"></a></dt>
    <dd><b>Clear</b> . Clears the selected region to the 'current
        color', which is set using the pixel measurement tool.
        See &quot;<a
        href="image-window.html#displaying-pixel-values">Displaying
        Pixel Values</a>&quot; .<br>
        Keyboard Equivalent: <b>&lt;Meta&gt; d</b> </dd>
</dl>

<h2><a name="pad-command">The Pad Command</a></h2>

<p>The <b>Pad</b> command is the opposite of the <b>Crop</b>
command. Sort of. It lets you add a border of a specified size to
the edges of the image. It also lets you resize images to some
desired size without manually expanding or cropping the image.
But it goes further than that. There are a whole slew of
interesting effects available, as described below:</p>

<dl>
    <dt><a name="pad"><img src="images/fig-071.gif" width="36"
        height="25"></a></dt>
    <dd><b>Pad</b> . Brings up the dialog box shown below.<br>
        Keyboard Equivalent: <b>P</b></dd>
</dl>

<p><a name="pad-window"><img src="images/fig-072.gif" width="494"
height="245"> </a></p>

<h3><a name="pad-methods">Pad Methods</a></h3>

<table border="0" cellpadding="4">
    <tr>
        <td valign="top"><a name="pad-method-menu"><img
        src="images/fig-074.gif" width="145" height="52"></a></td>
        <td>There are three primary <b>Pad</b> methods, as shown
        to the left. These methods are accessible via the 'Pad
        Method' menu, which says 'Solid Fill' in the dialog box
        shown above. In all cases, the <b>Pad</b> command
        operates in the same basic way: A new image of the
        desired size is created, it is filled as specified, and
        the original image is pasted onto this new image,
        centered. If the new image is smaller than the original
        image, the original image will be cropped. Otherwise, the
        area outside the original image will have the new
        background.</td>
    </tr>
</table>

<p>Note: The new, padded image will have the same 8/24-bit mode
as the original. As such, you <i>probably</i> want to switch to <b>24-bit
Mode</b> <i>before</i> issuing the <b>Pad</b> command,
particularly if you intend to modify the image further. (See
&quot;<a href="control-window-3.html#bit-menu">The 24/8 Bit Menu</a>&quot;
.)</p>

<p>The 'Pad Method' menu gives you three different ways of
filling the background:</p>

<dl>
    <dt><a name="solid-fill"><img src="images/fig-073.gif"
        width="141" height="16"></a></dt>
    <dd>The background is filled with a solid color. The color
        may be specified by name, (as specified in the X11 ' <tt>rgb.txt</tt>
        ' file), by RGB values in the range 0- 255, separated by
        commas (e.g. '0,255,128'), or by RGB values in
        hexadecimal (e.g. '0x00ff80'). In each case, the string
        you enter is parsed, and the background is filled solid
        with the specified color. </dd>
    <dt>&nbsp;</dt>
    <dt><a name="run-bggen"><img src="images/fig-075.gif"
        width="141" height="16"></a></dt>
    <dd>The external program <i>bggen</i> is executed to generate
        the background. This program is normally distributed with
        <i>xv</i>, and <i>xv</i> assumes that the executable is
        located somewhere in your search path (such as ' <tt>/usr/local/bin/bggen</tt>
        '). <i>bggen</i> can generate background gradients, at a
        specified angle. The gradient can be the entire size of
        the background, or it can repeat multiple times. See
        &quot;<a href="external-programs.html">External Programs</a>&quot;
        for a complete description of the <i>bggen</i> command. </dd>
    <dt>&nbsp;</dt>
    <dt><a name="load-image"><img src="images/fig-076.gif"
        width="141" height="16"></a></dt>
    <dd>An image file in any of the <i>xv</i>-supported formats
        may be loaded and used as the background. In this case,
        the background size (and therefore the size of the padded
        image) is equal to the size of the loaded background
        image. If you want a different size, you can load the
        background image (as a regular image), resize it as you
        see fit, save it, and use the newly saved version as the
        background for the original image. </dd>
</dl>

<h3><a name="size-dials">Image Size Dials</a></h3>

<table border="0" cellpadding="4" cellspacing="4">
    <tr>
        <td valign="top"><img src="images/fig-077.gif"
        width="157" height="123"></td>
        <td valign="top">These dials let you specify the size of
        the new, padded image in the &quot;Solid&quot; and
        &quot;Run 'bggen'&quot; modes. In the &quot;Load
        Image&quot; mode, the dials are disabled, as the new
        image size is dictated by the size of the loaded image.<p>If
        the image size dials are enabled, the small button above
        them resets them to the size of the currently-loaded
        image. Note that padding with the 'new' size equal to the
        current size won't actually <i>do</i> anything, unless
        you change the &quot;Opaque&quot; dial, described below.</p>
        </td>
    </tr>
</table>

<h3><a name="opaque-ness">Opaque-ness</a></h3>

<table border="0" cellpadding="4" cellspacing="4">
    <tr>
        <td valign="top"><img src="images/fig-078.gif" width="81"
        height="123"></td>
        <td valign="top">This dial sets the 'opaque-itude' of the
        foreground (the original image). Normally, this is set to
        '100%', which simply means that everywhere the original
        image and the background overlap, the original image is
        what you'll see. If you set the dial to '0%', then
        wherever the original image and the background overlap,
        the background is what you'll see. In any case, at points
        where the foreground image does <i>not</i> overlap the
        background, you'll see the background, unmodified.
        (Practical upshot: at '0%' you will <i>only</i> see the
        background.)</td>
    </tr>
</table>

<p>Of course, most of the interesting effects happen when the
dial is set to intermediate values, where the foreground image
will appear semi-transparent.</p>

<p>There are four modes the 'Opaque' dial can operate in. They
are selected by clicking the button located above the 'Opaque'
dial.</p>

<h4><a name="rgb">RGB</a></h4>

<p>The two images are blended together in the most obvious way.
Each RGB color component in the new image is computed by taking a
weighted average of the RGB components from the appropriate
pixels in the foreground and background images. Like so:</p>

<dl>
    <dd><i>R</i> <i>new</i> <i>= </i>( <i>opaque%</i> * <i>R</i> <i>fg</i>
        ) + ( (100 - <i>opaque%</i> ) * <i>R</i> <i>bg</i> ) <i>(same
        for G and B)</i> </dd>
</dl>

<h4><a name="int">INT</a></h4>

<p>On overlapping pixels, only the <i>Intensity</i> components
(the 'V' in the HSV colorspace, see &quot;<a
href="rgb-hsv-colorspaces.html">RGB &amp; HSV Colorspaces</a>&quot;
) of the pixels are blended, using the same weighted average
calculation shown above. If you set the 'Opaque' value to '0%',
brightness of overlapping pixels will be completely determined by
the 'background' pixel. It's possible to get some interesting
'masking' effects and whatnot by playing around with
black&amp;white backgrounds.</p>

<h4><a name="sat">SAT</a></h4>

<p>Similar to <b>INT</b>, except that it is the <i>Saturation</i>
component (the 'S' in the HSV colorspace, see &quot;<a
href="rgb-hsv-colorspaces.html">RGB &amp; HSV Colorspaces</a>&quot;
) of the two pixels that will be blended together, again using
the weighted average calculation. The effects possible with this
one are considerably more subtle, and not necessarily
interesting. It is mainly included for completeness.</p>

<h4><a name="hue">HUE</a></h4>

<p>In this case, the colors of the two overlapping pixels are
blended. You can get some interesting effects by setting 'Opaque'
to '0%', and loading a colorful rainbow background. In this case,
at all overlapping pixels, it will be as if the foreground image
were a greyscale transparency, as the brightness and saturation
will be controlled by the foreground, and the color will be
controlled by the background.</p>

<p>Technical Note: The <b>HUE</b> case does <i>not</i> simply do
a weighted average of the two hue components. Instead, it plots
the two points on the edge of a standard color wheel, draws a
straight line between them, and picks a point along this line
based on the 'Opaque' value (i.e., the larger the value, the
closer it is to the 'foreground' endpoint of the line). As a
result, the <b>HUE</b> setting can affect <i>both</i> the hue and
saturation components of the computed pixel. While this makes
this 'Opaque' mode somewhat unlike the others, once again it is a
fine example of xv's trademark &quot;Do The Right Thing&quot;
technology.</p>

<hr color="#000080">

<p>
<MAP NAME="FrontPageMap">
<AREA SHAPE="RECT" COORDS="393, 0, 453, 24" HREF="control-window-5.html">
<AREA SHAPE="RECT" COORDS="331, 0, 387, 24" HREF="control-window-3.html">
<AREA SHAPE="RECT" COORDS="263, 0, 323, 24" HREF="manindex.html">
<AREA SHAPE="RECT" COORDS="164, 0, 254, 24" HREF="index.html#Table+of+Contents">
</MAP>
<img src="images/navbar.gif" width="630" ismap usemap="#FrontPageMap"
height="25" border="0">
</p>
</body>
</html>
